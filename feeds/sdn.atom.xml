<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>YsY记录点滴</title><link href="http://ysywh.github.io/" rel="alternate"></link><link href="http://ysywh.github.io/feeds/sdn.atom.xml" rel="self"></link><id>http://ysywh.github.io/</id><updated>2015-08-30T17:30:00+08:00</updated><entry><title>OVS源码分析----OpenFlow消息处理</title><link href="http://ysywh.github.io/pages/2015/05/02/OVS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%94%E2%80%94%E2%80%94OpenFlow%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86.html" rel="alternate"></link><updated>2015-08-30T17:30:00+08:00</updated><author><name>ysy</name></author><id>tag:ysywh.github.io,2015-05-02:pages/2015/05/02/OVS源码分析————OpenFlow消息处理.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;OVS作为交换机，可以通过安全通道与控制器进行消息交互。控制器向OVS下发Openflow消息，可以完成对数据层面策略下发，流控制等功能。OVS接收到控制器下发的Openflow消息，需要对其进行接收，解析与处理，如安装流表项等操作。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;下文按照OVS接收处理openflow消息的处理流程进行分析：&lt;/p&gt;
&lt;p&gt;handle_openflow(ofproto\ofproto.c)开始对openflow消息进行具体处理，因此这个函数开始进行分析。首先说明一个重要数据结构。&lt;/p&gt;
&lt;p&gt;数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ofconn(ofproto\connmgr.c)：代表ovs和控制器之间的一次openflow连接。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主要的成员&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;connmgr（连接管理器）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rconn（一次可靠地openflow连接）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1 static bool  handle_openflow(struct ofconn &lt;em&gt;ofconn, struct ofpbuf &lt;/em&gt;ofp_msg)&lt;/h4&gt;
&lt;p&gt;接收控制器下发的openflow消息，并且调用函数handle_openflow__进行消息类别判断，做出对应的处理。若接收到错误的openflow消息则会返回error，向控制器发“error消息”进行回复。&lt;/p&gt;
&lt;h4&gt;2 satic enum ofperr handle_openflow__(struct ofconn &lt;em&gt;ofconn, const struct ofpbuf &lt;/em&gt;msg)&lt;/h4&gt;
&lt;p&gt;数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ofp_header：openflow消息packets头部。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据成员&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;version（openflow消息版本号）&lt;/li&gt;
&lt;li&gt;type（openflow消息类型）&lt;/li&gt;
&lt;li&gt;length(openflow消息长度)&lt;/li&gt;
&lt;li&gt;xid（每次openflow消息id号，回复使用相同xid）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先从接收到的消息msg中提取出openflow消息头部msg-&amp;gt;data，赋值给oh。oh利用函数ofptype_decode获得openflow消息类型type（枚举型ofptype中罗列了各种消息类型，lib\ofp-msgs.h）。通过判别type找到与消息类型相符的具体消息处理函数，从而进行消息处理。比如下面详细分析一下flowmod消息。&lt;/p&gt;
&lt;h4&gt;3 static enum ofperr handle_flow_mod(struct ofconn &lt;em&gt;ofconn, const struct ofp_header &lt;/em&gt;oh)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ofputil_flow_mod（lib\ofp-util.h）：flowmod消息的数据结构&lt;ul&gt;
&lt;li&gt;数据成员&lt;ul&gt;
&lt;li&gt;match: 匹配域定义和掩码定义（match有两个成员flow（定义了可以匹配的各个字段）和flow_wildcards（bit掩码）)&lt;/li&gt;
&lt;li&gt;priority，cookie，command，buffer_id,out_port和&lt;/li&gt;
&lt;li&gt;ofpact：ofpact是action的头部，含有type等成员&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过函数ofpbuf_use_stub给ofpacts分配一块缓存opfbuf，然后通过调用函数ofputil_decode_flow_mod得到数据结构ofputil_flow_mod实体fm和实体ofpacts，则此时fm即包含flowmod消息格式的各个字段内容，而ofpacts缓存中含有action，并其中fm中的成员ofpacts指向这个缓存ofpacts。最后调用函数handle_flow_mod__，函数中，根据flowmod消息fm的command类型不同（五种），选择command相应流表项处理函数，在用户空间插入、修改或是删除流表项。&lt;/p&gt;
&lt;h4&gt;4 static enum ofperr add_flow(struct ofproto *ofproto, struct ofconn *ofconn,const struct ofputil_flow_mod *fm, const struct ofp_header *request)&lt;/h4&gt;
&lt;p&gt;选择flowmod指定id的表，根据flowmod消息创建分类流规则rule，并且插入rule，等再有相同流过来进行匹配，从而创建流表项。具体如下：&lt;/p&gt;
&lt;p&gt;先通过fm-&amp;gt;table_id获得flowmod指定id的流表，如果id号大于指定的最大流表数则会返回相应error类型。找到table id后，根据函数rule_alloc()分配一个分类器rule，随后调用函数cls_rule_init(&amp;amp;rule-&amp;gt;cr, &amp;amp;fm-&amp;gt;match, fm-&amp;gt;priority)填充rule-&amp;gt;cr，则rule的匹配域和优先级字段基本填充完成。之后进行冲突检测（check for overlap），防止重复添加相同rule。之后对rule各个字段进行填充，调用函数oftable_replace_rule插入这个初始化好的rule。&lt;/p&gt;
&lt;p&gt;这样addflow任务基本完成，等待以后相同流在核心层匹配失败后，upcall到用户层，则会根据匹配这个rule进行流表项的建立工作，如果不存在匹配的rule，则会丢弃或是上交controller，具体见用户态处理upcall消息分析。至于modify和delete类型flowmod消息，基本分析相同，如对command为modify的flowmod消息，则修改指定rule的action。&lt;/p&gt;</summary><category term="OVS souce code"></category></entry><entry><title>Cbench测试Opendaylight性能</title><link href="http://ysywh.github.io/pages/2015/04/03/Cbench%E6%B5%8B%E8%AF%95Opendaylight%E6%80%A7%E8%83%BD.html" rel="alternate"></link><updated>2015-08-30T17:30:00+08:00</updated><author><name>ysy</name></author><id>tag:ysywh.github.io,2015-04-03:pages/2015/04/03/Cbench测试Opendaylight性能.html</id><summary type="html">&lt;p&gt;&lt;/br&gt;&lt;/p&gt;
&lt;p&gt;要求和目标：用Cbench测试Opendaylight控制器的吞吐量和延时性能，拓扑简单设定为四个交换机&lt;/p&gt;
&lt;p&gt;实验通过Cbench模拟出拓扑，并对Opendaylight进行测试。&lt;/p&gt;
&lt;h3&gt;一：测试平台：&lt;/h3&gt;
&lt;p&gt;由于测试结果和测试平台的性能紧密联系，因此记录下测试平台参数。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;硬件参数：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CPU: Intel(R) Xeon(R) CPU E5-2609 0 @ 2.40GHz&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Memory: 8GB DDR3 - 1600 Mhz&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;软件参数:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;OS: Ubuntu 14.04&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java: OpenJDK java version "1.7.0"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Opendaylight版本:Helium-SR2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Opendaylight设置为初始默认值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;二：测试步骤&lt;/h3&gt;
&lt;p&gt;准备工作：先安装好&lt;a href="https://www.opendaylight.org/downloads"&gt;OpenDaylight&lt;/a&gt;和&lt;a href="https://github.com/deepurple/cbench-src"&gt;Cbench&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;1 开启opendaylight:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://7xnkv8.com1.z0.glb.clouddn.com/cbench1.png" /&gt;&lt;/p&gt;
&lt;p&gt;2 安装Opendaylight控制器测试组件：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://7xnkv8.com1.z0.glb.clouddn.com/cbench2.png" /&gt;&lt;/p&gt;
&lt;p&gt;说明：Opendaylight不同于其他控制器，需要测试组件的支持，且测试组件具有两种测试模式：RPC和data store模式（区别见最后说明），以下分别用Cbench进行吞吐量和延时的测试.&lt;/p&gt;
&lt;h3&gt;RPC模式性能测试&lt;/h3&gt;
&lt;p&gt;首先，在RPC模式下进行Opendaylight性能测试：&lt;/p&gt;
&lt;p&gt;1 在opendaylight中开启RPC模式的测试组件：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://7xnkv8.com1.z0.glb.clouddn.com/cbench3.png" /&gt;&lt;/p&gt;
&lt;p&gt;2 开启Cbench，测试控制器吞吐量(throughput)性能:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://7xnkv8.com1.z0.glb.clouddn.com/cbench4.png" /&gt;&lt;/p&gt;
&lt;p&gt;这里简单说明一下参数意义，s是交换机数量，M是每个交换机连接的主机数量，m是每次测试周期，l是测试循环次数，-t是进行吞吐量throughput测试，没有t则是延时latency测试。后面测试命令不再赘述。&lt;/p&gt;
&lt;p&gt;吞吐量测试结果截图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://7xnkv8.com1.z0.glb.clouddn.com/cbench5.png" /&gt;&lt;/p&gt;
&lt;p&gt;测试结果简单解释：截图第二行显示测试性能的方面，可以看到是throughout，则是吞吐量测试。测试结果有10行数据，每行代表一次测试，每行有4个结果，单位是秒，代表每个交换机的测试结果，最后会有每毫秒的结果。最后一行是测试总的结果。&lt;/p&gt;
&lt;p&gt;3 开启Cbench，测试控制器延时（latency）性能：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://7xnkv8.com1.z0.glb.clouddn.com/cbench6.png" /&gt;&lt;/p&gt;
&lt;p&gt;测试结果截图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://7xnkv8.com1.z0.glb.clouddn.com/cbench7.png" /&gt;&lt;/p&gt;
&lt;p&gt;特别说明：延迟测试结果要对测试的结果取倒数才是延迟。&lt;/p&gt;
&lt;h3&gt;data store模式性能测试&lt;/h3&gt;
&lt;p&gt;其次，在data store模式下进行Opendaylight性能测试:&lt;/p&gt;
&lt;p&gt;1关闭RPC模式，开启data store模式的测试组件：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://7xnkv8.com1.z0.glb.clouddn.com/cbench8.png" /&gt;&lt;/p&gt;
&lt;p&gt;2 开启Cbench，测试控制器吞吐量(throughput)性能:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://7xnkv8.com1.z0.glb.clouddn.com/cbench9.png" /&gt;&lt;/p&gt;
&lt;p&gt;吞吐量测试结果截图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://7xnkv8.com1.z0.glb.clouddn.com/cbench10.png" /&gt;&lt;/p&gt;
&lt;p&gt;3 开启Cbench，测试控制器延时（latency）性能：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://7xnkv8.com1.z0.glb.clouddn.com/cbench11.png" /&gt;&lt;/p&gt;
&lt;p&gt;延迟测试结果截图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://7xnkv8.com1.z0.glb.clouddn.com/cbench12.png" /&gt; &lt;/p&gt;
&lt;h3&gt;说明&lt;/h3&gt;
&lt;p&gt;1 两种模式特别说明，来自Opendaylight官网：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RPC : programming flows directly through an RPC to the OF Plugin&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;data store : programming flows by writing them into the MD-SAL config space, from where they are picked up by the FRM and programmed into the plugin)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2 参数命令和结果截图说明见4和5，之后的不再赘述。&lt;/p&gt;
&lt;p&gt;3 测试结果的文本数据，见附件result.txt&lt;/p&gt;</summary><category term="Cbench OpenDaylight"></category></entry></feed>